# python-sqlite-ast: Implementation Specification

## Goal

Build a pure Python library (no C extensions, no external dependencies) that takes a SQLite SELECT query string and returns an AST as a nested Python dictionary structure that exactly matches the 90 test fixtures in `/tmp/sqlite-ast-conformance/ast-tests/`.

The conformance tests were generated by hooking into SQLite's own Lemon parser at the grammar action level, so our output must replicate not just the parse tree shape, but also several constant-folding and normalization behaviors that SQLite applies during parsing.

## Architecture

```
SQL string
    │
    ▼
┌──────────┐
│ Tokenizer│  → Stream of Token(type, value, pos)
└──────────┘
    │
    ▼
┌──────────┐
│  Parser  │  → Nested Python dicts (the AST)
└──────────┘
```

Two modules:

1. **`tokenizer.py`** — Hand-written lexical scanner producing tokens.
2. **`parser.py`** — Recursive descent parser with Pratt-style precedence climbing for expressions.

Public API in `__init__.py`:

```python
def parse_select(sql: str) -> dict:
    """Parse a SQLite SELECT statement and return the AST as a dict."""
```

## Tokenizer Design

### Token Types

The tokenizer produces tokens with a `type` field from this set:

| Category | Token Types |
|----------|------------|
| Keywords | `SELECT`, `FROM`, `WHERE`, `GROUP`, `BY`, `HAVING`, `ORDER`, `LIMIT`, `OFFSET`, `AS`, `ON`, `USING`, `JOIN`, `LEFT`, `RIGHT`, `FULL`, `OUTER`, `INNER`, `CROSS`, `NATURAL`, `AND`, `OR`, `NOT`, `IS`, `IN`, `BETWEEN`, `LIKE`, `GLOB`, `MATCH`, `CASE`, `WHEN`, `THEN`, `ELSE`, `END`, `CAST`, `EXISTS`, `DISTINCT`, `ALL`, `UNION`, `INTERSECT`, `EXCEPT`, `WITH`, `RECURSIVE`, `MATERIALIZED`, `NULL`, `ESCAPE`, `COLLATE`, `ISNULL`, `NOTNULL`, `WINDOW`, `OVER`, `PARTITION`, `RANGE`, `ROWS`, `GROUPS`, `UNBOUNDED`, `PRECEDING`, `FOLLOWING`, `CURRENT`, `ROW`, `EXCLUDE`, `OTHERS`, `TIES`, `FILTER`, `VALUES`, `NULLS`, `FIRST`, `LAST` |
| Literals | `INTEGER`, `FLOAT`, `STRING`, `BLOB` |
| Identifiers | `ID` (bare identifiers, quoted identifiers, and keyword-as-identifier fallbacks) |
| Parameters | `PARAMETER` (?, ?N, :name, @name, $name) |
| Operators | `PLUS`, `MINUS`, `STAR`, `SLASH`, `REM`, `EQ`, `NE`, `LT`, `LE`, `GT`, `GE`, `BITAND`, `BITOR`, `BITNOT`, `LSHIFT`, `RSHIFT`, `CONCAT` |
| Punctuation | `LPAREN`, `RPAREN`, `COMMA`, `DOT`, `SEMICOLON` |
| Special | `EOF` |

### Keyword vs Identifier Fallback

Following SQLite's `%fallback ID` rule, many keywords can be used as identifiers. The tokenizer will first try to match keywords, but the parser will treat certain keywords as identifiers when they appear in expression context and don't match a keyword-specific grammar rule. Keywords that fall back to ID include: `ABORT`, `ACTION`, `AFTER`, `ANALYZE`, `ASC`, `ATTACH`, `BEFORE`, `BEGIN`, `BY`, `CASCADE`, `CAST`, `CONFLICT`, `DATABASE`, `DEFERRED`, `DESC`, `DETACH`, `DO`, `EACH`, `END`, `EXCLUSIVE`, `EXPLAIN`, `FAIL`, `FOR`, `IGNORE`, `IMMEDIATE`, `INITIALLY`, `INSTEAD`, `LIKE`, `GLOB`, `MATCH`, `NO`, `PLAN`, `QUERY`, `KEY`, `OF`, `OFFSET`, `PRAGMA`, `RAISE`, `RECURSIVE`, `RELEASE`, `REPLACE`, `RESTRICT`, `ROW`, `ROWS`, `ROLLBACK`, `SAVEPOINT`, `TEMP`, `TRIGGER`, `VACUUM`, `VIEW`, `VIRTUAL`, `WITH`, `WITHOUT`, `NULLS`, `FIRST`, `LAST`, `CURRENT`, `FOLLOWING`, `PARTITION`, `PRECEDING`, `RANGE`, `UNBOUNDED`, `EXCLUDE`, `GROUPS`, `OTHERS`, `TIES`, `MATERIALIZED`, `TRUE`, `FALSE`.

Note: **`TRUE` and `FALSE` are treated as identifiers** (type `"name"`) in the AST, not as boolean literals. This matches SQLite's behavior where they fall back to ID tokens.

### Tokenizer Rules

- **Whitespace**: Skip spaces, tabs, newlines.
- **Comments**: `--` to end of line; `/* ... */` block comments.
- **Strings**: `'...'` with `''` as escaped single quote. Token value is the unescaped content (without outer quotes).
- **Blobs**: `X'hex'` or `x'hex'`. Token value is the full original text including `X'...'`.
- **Identifiers**: `[A-Za-z_][A-Za-z0-9_]*`. Also `"quoted"` (double-quoted) and `` [bracketed] ``.
- **Numbers**: Integer or float. `123`, `0x1A`, `3.14`, `1.0e10`, `.5`. If the number contains a `.` or `e`/`E`, it's a FLOAT; otherwise INTEGER.
- **Parameters**: `?`, `?123`, `:name`, `@name`, `$name`.
- **Multi-char operators**: `<=`, `>=`, `!=`, `<>`, `<<`, `>>`, `||`.
- **Single-char operators/punctuation**: `+`, `-`, `*`, `/`, `%`, `=`, `<`, `>`, `&`, `|`, `~`, `(`, `)`, `,`, `.`, `;`.

## Parser Design

### Overall Structure

The parser is a recursive descent parser. The main entry point parses either:
1. A `WITH` clause followed by a select-or-compound
2. A `VALUES` clause (special handling)
3. A simple `SELECT` or compound select (`SELECT ... UNION SELECT ...`)

### Expression Parsing (Pratt / Precedence Climbing)

Expressions use a Pratt parser with these precedence levels (lowest to highest):

| Level | Operators | Associativity |
|-------|-----------|---------------|
| 1 | `OR` | Left |
| 2 | `AND` | Left |
| 3 | `NOT` (unary prefix) | Right |
| 4 | `=`, `==`, `!=`, `<>`, `IS`, `IS NOT`, `IN`, `LIKE`, `GLOB`, `MATCH`, `BETWEEN`, `ISNULL`, `NOTNULL` | Left |
| 5 | `<`, `<=`, `>`, `>=` | Left |
| 6 | `&`, `\|`, `<<`, `>>` | Left |
| 7 | `+`, `-` (binary) | Left |
| 8 | `*`, `/`, `%` | Left |
| 9 | `\|\|` (concat) | Left |
| 10 | `COLLATE` | Left |
| 11 | `~` (unary prefix), `-` (unary prefix), `+` (unary prefix) | Right |

### Prefix (Nud) Expressions

- **Integer literal**: `{"type": "integer", "value": <int>}`
- **Float literal**: `{"type": "float", "value": "<string>"}` — value is the original text representation
- **String literal**: `{"type": "string", "value": "<unescaped>"}`
- **Blob literal**: `{"type": "blob", "value": "X'...'"}`
- **NULL**: `{"type": "null"}`
- **Identifier / TRUE / FALSE**: `{"type": "name", "name": "<text>"}`
- **Star (`*`)**: `{"type": "star"}`
- **Parameter**: `{"type": "parameter", "name": "<text>"}`
- **Unary `-`**: `{"type": "unary", "op": "-", "operand": <expr>}`
- **Unary `+`**: `{"type": "unary", "op": "+", "operand": <expr>}`
- **Unary `~`**: `{"type": "unary", "op": "~", "operand": <expr>}`
- **Unary `NOT`**: `{"type": "unary", "op": "NOT", "operand": <expr>}`
- **Parenthesized expr**: parse inner expression, or subquery if starts with `SELECT`
- **CAST**: `{"type": "cast", "expr": <expr>, "as": "<type_name>"}`
- **CASE**: `{"type": "case", "operand": <expr|null>, "when_clauses": [...], "else": <expr|null>}`
- **EXISTS**: `{"type": "exists", "select": <select>}`
- **Scalar subquery `(SELECT ...)`**: `{"type": "subquery", "select": <select>}`

### Infix / Postfix (Led) Expressions

- **Binary operators** (`+`, `-`, `*`, `/`, `%`, `||`, `&`, `|`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `=`, `!=`, `AND`, `OR`, `IS`, `IS NOT`):
  `{"type": "binary", "op": "<op>", "left": <expr>, "right": <expr>}`
- **Dot (qualified name)**: `{"type": "dot", "left": <expr>, "right": <expr>}`
  - When followed by `*`: right is `{"type": "star"}`
- **COLLATE**: `{"type": "collate", "expr": <expr>, "collation": "<name>"}`
- **ISNULL**: `{"type": "isnull", "operand": <expr>}` (postfix keyword)
- **NOTNULL**: `{"type": "notnull", "operand": <expr>}` (postfix keyword)
- **IS NULL**: `{"type": "isnull", ...}` (special case of IS where right side is NULL)
- **IS NOT NULL**: `{"type": "notnull", ...}` (special case of IS NOT where right side is NULL)
- **BETWEEN**: `{"type": "between", "expr": <expr>, "low": <expr>, "high": <expr>}`
- **NOT BETWEEN**: `{"type": "unary", "op": "NOT", "operand": {"type": "between", ...}}`
- **IN (list)**: `{"type": "in", "expr": <expr>, "values": [<expr>, ...]}`
- **IN (subquery)**: `{"type": "in", "expr": <expr>, "select": <select>}`
- **NOT IN**: `{"type": "unary", "op": "NOT", "operand": {"type": "in", ...}}`
- **LIKE / GLOB / MATCH**: Converted to function call (see "SQLite-Specific Behaviors" below)
- **Function call** `name(args)`: `{"type": "function", "name": "<name>", "args": [...], "distinct": <bool>}`
  - With OVER clause: adds `"over"` key (see Window Functions)

### SELECT Statement

```python
{
    "type": "select",
    "distinct": bool,
    "all": bool,
    # "with": [...],              # ONLY present when WITH clause is used
    "columns": [{"expr": <expr>, "alias": <str|null>}, ...],
    "from": <null | [<from_item>, ...]>,
    "where": <null | expr>,
    "group_by": <null | [expr, ...]>,
    "having": <null | expr>,
    # "window_definitions": [...], # ONLY present when WINDOW clause used
    "order_by": <null | [{"expr": <expr>, "direction": "ASC"|"DESC", ...}, ...]>,
    "limit": <null | expr>,
    # "offset": <null | expr>,    # ONLY present when limit is present
}
```

**Key presence rules:**
- `with` — only present when there's a WITH clause
- `window_definitions` — only present when there's a WINDOW clause
- `offset` — only present when `limit` is present (even if offset is null)
- All other keys are always present

### Compound SELECT

```python
{
    "type": "compound",
    "body": [
        {"select": <select_node>},                           # first
        {"operator": "UNION"|"UNION ALL"|..., "select": <select_node>},  # subsequent
        ...
    ],
    "order_by": <null | [...]>,
    "limit": <null | expr>,
    # "offset": <null | expr>,  # only when limit present
}
```

Individual selects inside a compound do NOT include `order_by` or `limit` keys.

### FROM Clause Items

**Table:**
```python
{
    "type": "table",
    "name": "<table_name>",
    # "schema": "<schema>",    # only present for schema-qualified (e.g., values_clause)
    "alias": <str|null>,
    "join_type": <str|null>,   # null for first table, "JOIN", "LEFT JOIN", etc.
    # "on": <expr>,            # only when ON clause used
    # "using": [<str>, ...],   # only when USING clause used
}
```

**Subquery:**
```python
{
    "type": "subquery",
    "select": <select_node>,
    "alias": <str|null>,
    "join_type": <str|null>,
    # "on": <expr>,            # only when ON clause used
}
```

**Join types** (string values): `"JOIN"`, `"LEFT JOIN"`, `"RIGHT JOIN"`, `"FULL OUTER JOIN"`, `"CROSS JOIN"`, `"NATURAL JOIN"`, `"NATURAL LEFT JOIN"`, `"NATURAL RIGHT JOIN"`, etc.

### WITH / CTE

```python
{
    "name": "<cte_name>",
    # "columns": ["col1", "col2"],  # only when CTE has column list
    # "materialized": "MATERIALIZED" | "NOT MATERIALIZED",  # only when specified
    "select": <select_or_compound>
}
```

### Window Functions

**Window in `over` key of function:**
```python
{
    "name": <str|null>,        # window name if referencing named window
    "base": <str|null>,        # base window name
    # "partition_by": [...],   # only when PARTITION BY used
    # "order_by": [...],       # only when ORDER BY used
    # "frame": {...},          # when frame specification present
    # "filter": <expr>,        # only when FILTER clause used
}
```

**Frame specification:**
```python
{
    "type": "RANGE" | "ROWS" | "GROUPS",
    "start": {"type": "UNBOUNDED" | "CURRENT ROW" | "PRECEDING" | "FOLLOWING", "expr": <expr>},
    "end": {"type": "UNBOUNDED" | "CURRENT ROW" | "PRECEDING" | "FOLLOWING", "expr": <expr>}
}
```

### ORDER BY Items

```python
{
    "expr": <expr>,
    "direction": "ASC" | "DESC",
    # "nulls": "FIRST" | "LAST"  # only when NULLS clause specified
}
```

## SQLite-Specific Behaviors to Replicate

These are behaviors where the AST output differs from a naive parse tree because SQLite applies transformations during parsing.

### 1. AND Constant Folding

SQLite's `sqlite3ExprAnd()` folds AND expressions when one side is a constant false:

- If either operand is integer literal `0`, the AND folds to `{"type": "integer", "value": 0}`.
- More precisely: if either operand has the "IsFalse" property (integer 0), and neither has function calls or ON-clause markers, fold to integer 0.

**Test**: `expr_logical.json` — `SELECT 1 AND 0 OR 1` → `OR(integer(0), integer(1))` because `1 AND 0` folds to `0`.

Implementation: When constructing an AND node, check if either operand is `{"type": "integer", "value": 0}`. If so, return integer 0 instead of the AND node.

### 2. IS NULL / IS NOT NULL Folding

- `expr IS NULL` → `{"type": "isnull", "operand": <expr>}` (not a binary IS with NULL right side)
- `expr IS NOT NULL` → `{"type": "notnull", "operand": <expr>}`

Additional constant folding: if the operand of IS NULL / IS NOT NULL / ISNULL / NOTNULL is a literal (integer, float, string, blob), fold to a constant:
- `literal ISNULL` / `literal IS NULL` → `{"type": "integer", "value": 0}` (literals are never null)
- `literal NOTNULL` / `literal IS NOT NULL` → `{"type": "integer", "value": 1}`

When checking for literals, look through unary plus/minus wrappers: `-(1) IS NULL` should still fold because the inner expression is a literal.

### 3. LIKE / GLOB / MATCH as Function Calls

`expr LIKE pattern` is converted to a function call with **reversed argument order**:
```python
{"type": "function", "name": "LIKE", "args": [<pattern>, <expr>], "distinct": false}
```

With ESCAPE:
```python
{"type": "function", "name": "LIKE", "args": [<pattern>, <expr>, <escape>], "distinct": false}
```

`NOT LIKE` wraps the function in a NOT unary:
```python
{"type": "unary", "op": "NOT", "operand": {"type": "function", "name": "LIKE", ...}}
```

Same pattern applies to `GLOB` and `MATCH`.

### 4. NULLS FIRST/LAST with DESC (BIGNULL normalization)

The output represents the internal BIGNULL flag, not the SQL keyword directly:

| SQL Direction | SQL Nulls | Output `nulls` |
|---------------|-----------|-----------------|
| ASC | NULLS FIRST | `"FIRST"` |
| ASC | NULLS LAST | `"LAST"` |
| DESC | NULLS FIRST | `"LAST"` |
| DESC | NULLS LAST | `"FIRST"` |

Rule: `output = "FIRST"` if direction and nulls "agree" (both ASC or both DESC-like), `"LAST"` if they differ.

More precisely, BIGNULL is set when `sort_direction != nulls_value` (where NULLS FIRST = ASC = 0, NULLS LAST = DESC = 1). Output "LAST" when BIGNULL, "FIRST" when not.

### 5. VALUES Clause Transformation

`VALUES (1, 2), (3, 4), (5, 6)` is transformed by SQLite into:
```python
{
    "type": "select",
    "columns": [{"expr": {"type": "star"}, "alias": null}],
    "from": [{"type": "table", "name": "sqlite_master", "schema": "main", "alias": null, "join_type": null}],
    "order_by": [{"expr": {"type": "name", "name": "rowid"}, "direction": "ASC"}],
    ...
}
```

This is an internal SQLite transformation. We must emit this exact structure when parsing a VALUES clause.

### 6. JOIN USING — Unknown ON Node

`JOIN ... USING (id)` produces both an `on` and `using` key. The `on` key contains:
```python
{"type": "unknown", "op": 1}
```

This is an internal SQLite placeholder. We must emit this exact structure.

### 7. Implicit JOIN for Comma-Separated Tables

`FROM foo, bar` produces `join_type: "JOIN"` for the second (and subsequent) tables, not `null`. This matches SQLite's treatment of comma-separated FROM items as implicit inner joins.

### 8. count(*) — Empty Args

`count(*)` produces `{"type": "function", "name": "count", "args": [], "distinct": false}` — the `*` is not included in args; instead, args is an empty list.

### 9. Unary Plus Collapse

SQLite collapses `+(+expr)` to `+(expr)` — when a unary plus is applied to a unary plus, the inner operation is changed. This is a minor optimization in the parser. Whether we need this depends on whether any test exercises it (currently none do).

### 10. TRUE / FALSE as Identifiers

`TRUE` and `FALSE` are parsed as identifiers (`{"type": "name", "name": "TRUE"}` / `{"type": "name", "name": "FALSE"}`), NOT as boolean literals. This applies in all contexts.

## Open Questions

1. **VALUES clause**: The transformation of `VALUES (...)` into `SELECT * FROM sqlite_master ORDER BY rowid` is a deep internal SQLite behavior. Should we hard-code this exact output, or is there a more principled approach? **Current plan**: Hard-code it, since there's only one test and the conformance suite defines the expected output.

2. **Edge cases not covered by tests**: The conformance suite has 90 tests. Are there any SELECT features NOT covered that we should still handle? Examples: `REGEXP` operator, table-valued functions, `GROUP_CONCAT` with ORDER BY inside, `EXCLUDE` clause in window frames, schema-qualified table names (other than `values_clause`). **Current plan**: Focus on passing the 90 tests first; add support for untested features only if needed.

3. **Error handling**: How should parse errors be reported? **Current plan**: Raise a `ParseError` exception with a message indicating position and expected token. Not a priority for the initial implementation.

4. **The `expr_logical.json` AND constant folding** — The rule checks for integer 0 (EP_IsFalse). Should we also check for the `FALSE` identifier? In SQLite's source, `EP_IsFalse` is set on integer 0 and the `FALSE` keyword. But since `FALSE` is parsed as an identifier (name), it would NOT have EP_IsFalse in the same way. **Current plan**: Only fold when the operand is literally `{"type": "integer", "value": 0}`.

5. **Should the AND folding also consider the EP_IsTrue case?** Looking at SQLite source: `sqlite3ExprAnd` only checks EP_IsFalse (to fold to 0). It does NOT simplify `TRUE AND x` → `x`. The folding is only: if either side is definitely false, the whole AND is 0. **Current plan**: Only fold when either operand is integer 0. But we may also need to handle: when one operand is a non-zero integer literal and the result is the other operand. Actually, re-reading the code, `sqlite3ExprAnd` does NOT do this — it only checks EP_IsFalse. So we only need the "fold to 0" case. Wait — but the `expr_logical` test shows `1 AND 0` → `0`, not `AND(1, 0)`. This happens because both operands have EP flags: `1` has EP_IsTrue and `0` has EP_IsFalse. The check is `(f & (EP_OuterON|EP_InnerON|EP_IsFalse|EP_HasFunc)) == EP_IsFalse`, meaning EP_IsFalse must be in the combined flags and no OuterON/InnerON/HasFunc. So our check is: if either operand is integer literal 0 (which means EP_IsFalse is set in the combined flags), and neither operand contains a function call, fold to 0. For simplicity (since these are expression-level operands not ON-clause contexts), we can just check: **if either AND operand is integer literal 0, fold to integer 0**.

## Implementation Plan

### Phase 1: Tokenizer
- Implement the full tokenizer with all token types
- Handle strings, blobs, numbers, identifiers, keywords, operators, parameters
- Test with representative SQL strings

### Phase 2: Basic Expression Parser
- Implement Pratt parser for expressions
- Support all literal types, identifiers, binary ops, unary ops
- Support parenthesized expressions
- Support dot-qualified names
- Support function calls (including count(*))

### Phase 3: Simple SELECT
- Parse SELECT columns (with aliases)
- Parse FROM clause (single table, aliases)
- Parse WHERE, GROUP BY, HAVING
- Parse ORDER BY (with direction and NULLS)
- Parse LIMIT / OFFSET

### Phase 4: Advanced Expressions
- CASE (simple and searched)
- CAST
- BETWEEN / NOT BETWEEN
- IN (list) / IN (subquery) / NOT IN
- EXISTS
- Scalar subqueries
- LIKE / GLOB / MATCH (as function calls)
- COLLATE
- IS NULL / IS NOT NULL / ISNULL / NOTNULL
- IS TRUE / IS FALSE / IS NOT TRUE / IS NOT FALSE
- Parameters (?, ?N, :name, @name, $name)
- Blob literals

### Phase 5: JOINs and Subqueries
- All join types (JOIN, LEFT, RIGHT, FULL OUTER, CROSS, NATURAL)
- ON and USING clauses
- Subqueries in FROM
- Comma-separated tables (implicit JOIN)

### Phase 6: Compound SELECTs
- UNION, UNION ALL, INTERSECT, EXCEPT
- Compound with ORDER BY and LIMIT

### Phase 7: WITH / CTE
- Basic CTEs
- CTE with column list
- MATERIALIZED / NOT MATERIALIZED
- Recursive CTEs (WITH RECURSIVE)

### Phase 8: Window Functions
- OVER clause (inline and named)
- PARTITION BY, ORDER BY in windows
- Frame specifications (RANGE, ROWS, GROUPS)
- FILTER clause
- WINDOW clause (named window definitions)

### Phase 9: Special Cases
- AND constant folding
- IS NULL / ISNULL constant folding on literals
- VALUES clause transformation
- JOIN USING unknown ON node
- NULLS FIRST/LAST BIGNULL normalization
- Unary plus collapse (if needed)

### Phase 10: Conformance Testing
- Run all 90 test fixtures
- Fix any discrepancies
- Add the conformance test runner to the project's test suite
